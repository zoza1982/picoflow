# Multi-stage Dockerfile for cross-compiling PicoFlow
# Supports: ARM32, ARM64, x86_64 Linux targets
#
# Usage:
#   # Build for all platforms
#   docker build -f Dockerfile.build -t picoflow-builder .
#   docker run --rm -v $(pwd):/workspace picoflow-builder
#
#   # Build for specific target
#   docker run --rm -v $(pwd):/workspace picoflow-builder arm32
#   docker run --rm -v $(pwd):/workspace picoflow-builder arm64
#   docker run --rm -v $(pwd):/workspace picoflow-builder x86_64

# Force x86_64 platform for consistent cross-compilation
# This ensures gcc is x86_64-linux-gnu-gcc (native) which is needed for x86_64 builds
FROM --platform=linux/amd64 rust:1.83-slim as builder

# Enable multiarch for cross-compilation
RUN dpkg --add-architecture armhf && \
    dpkg --add-architecture arm64

# Install cross-compilation dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    crossbuild-essential-armhf \
    crossbuild-essential-arm64 \
    pkg-config \
    libssl-dev \
    libssl-dev:armhf \
    libssl-dev:arm64 \
    perl \
    curl \
    git \
    make \
    bc \
    && rm -rf /var/lib/apt/lists/*

# Set environment variables for cross-compilation
ENV PKG_CONFIG_ALLOW_CROSS=1
ENV OPENSSL_DIR=/usr
ENV OPENSSL_STATIC=1

# Install Rust targets
RUN rustup target add \
    armv7-unknown-linux-gnueabihf \
    aarch64-unknown-linux-gnu \
    x86_64-unknown-linux-gnu

# Set up cargo configuration for cross-compilation
RUN mkdir -p /root/.cargo
COPY .cargo/config.toml /root/.cargo/config.toml

# Set working directory
WORKDIR /workspace

# Copy entrypoint script (avoids heredoc which Podman misparses)
COPY docker-build-entrypoint.sh /build.sh
RUN chmod +x /build.sh

ENTRYPOINT ["/build.sh"]
CMD ["all"]
